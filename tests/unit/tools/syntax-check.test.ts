import { describe, it, expect, beforeEach, afterEach, vi } from 'bun:test';
import * as fs from 'node:fs';
import * as path from 'node:path';

import { syntaxCheck, type SyntaxCheckInput } from '../../../src/tools/syntax-check';
import type { PluginConfig } from '../../../src/config';

// Mock the saveEvidence function
vi.mock('../../../src/evidence/manager', () => ({
	saveEvidence: vi.fn().mockResolvedValue(undefined),
}));

describe('syntax_check tool', () => {
	let tmpDir: string;
	let originalCwd: string;

	beforeEach(async () => {
		originalCwd = process.cwd();
		tmpDir = fs.mkdtempSync(path.join(originalCwd, 'syntax-check-test-'));
		process.chdir(tmpDir);
	});

	afterEach(() => {
		if (tmpDir && fs.existsSync(tmpDir)) {
			fs.rmSync(tmpDir, { recursive: true, force: true });
		}
		process.chdir(originalCwd);
		vi.clearAllMocks();
	});

	// ============ Valid File Parsing ============

	describe('valid file parsing', () => {
		it('parses valid JavaScript file successfully', async () => {
			const testFile = path.join(tmpDir, 'test.js');
			fs.writeFileSync(testFile, 'const x = 1;\nconst y = 2;');

			const input: SyntaxCheckInput = {
				changed_files: [{ path: testFile, additions: 10 }],
				mode: 'changed',
			};

			const result = await syntaxCheck(input, tmpDir);

			expect(result.verdict).toBe('pass');
			expect(result.files).toHaveLength(1);
			expect(result.files[0]?.path).toBe(testFile);
			expect(result.files[0]?.ok).toBe(true);
			expect(result.files[0]?.language).toBe('javascript');
			expect(result.files[0]?.errors).toEqual([]);
		});

		it('parses valid Python file successfully', async () => {
			const testFile = path.join(tmpDir, 'test.py');
			fs.writeFileSync(testFile, 'def hello():\n    print("world")');

			const input: SyntaxCheckInput = {
				changed_files: [{ path: testFile, additions: 5 }],
				mode: 'changed',
			};

			const result = await syntaxCheck(input, tmpDir);

			expect(result.verdict).toBe('pass');
			expect(result.files).toHaveLength(1);
			expect(result.files[0]?.ok).toBe(true);
			expect(result.files[0]?.language).toBe('python');
		});

		it('filters files with no additions in changed mode', async () => {
			const testFile = path.join(tmpDir, 'test.js');
			fs.writeFileSync(testFile, 'const x = 1;');

			const input: SyntaxCheckInput = {
				changed_files: [{ path: testFile, additions: 0 }],
				mode: 'changed',
			};

			const result = await syntaxCheck(input, tmpDir);

			expect(result.files).toHaveLength(0);
		});
	});

	// ============ Syntax Error Detection ============

	describe('syntax error detection', () => {
		it('detects syntax errors in JavaScript', async () => {
			const testFile = path.join(tmpDir, 'invalid.js');
			// Missing closing parenthesis
			fs.writeFileSync(testFile, 'const x = function() { return 1;');

			const input: SyntaxCheckInput = {
				changed_files: [{ path: testFile, additions: 1 }],
				mode: 'changed',
			};

			const result = await syntaxCheck(input, tmpDir);

			expect(result.verdict).toBe('fail');
			expect(result.files).toHaveLength(1);
			expect(result.files[0]?.ok).toBe(false);
			expect(result.files[0]?.errors?.length).toBeGreaterThan(0);
		});

		it('detects syntax errors in Python', async () => {
			const testFile = path.join(tmpDir, 'invalid.py');
			// Invalid Python syntax
			fs.writeFileSync(testFile, 'def foo():\n    print("hello")\n    return');

			const input: SyntaxCheckInput = {
				changed_files: [{ path: testFile, additions: 1 }],
				mode: 'changed',
			};

			const result = await syntaxCheck(input, tmpDir);

			// Python syntax errors may or may not be caught depending on tree-sitter grammar
			expect(result.files).toHaveLength(1);
			// The file should be processed (not skipped)
			expect(result.files[0]?.skipped_reason).toBeUndefined();
		});
	});

	// ============ Binary File Detection ============

	describe('binary file detection', () => {
		it('skips binary files', async () => {
			const testFile = path.join(tmpDir, 'binary.bin');
			// Create a file with null bytes (binary content)
			const buffer = Buffer.alloc(1000, 0);
			fs.writeFileSync(testFile, buffer);

			const input: SyntaxCheckInput = {
				changed_files: [{ path: testFile, additions: 1 }],
				mode: 'changed',
			};

			const result = await syntaxCheck(input, tmpDir);

			expect(result.files).toHaveLength(1);
			expect(result.files[0]?.skipped_reason).toBe('binary_file');
		});

		it('handles files with some null bytes but below threshold', async () => {
			const testFile = path.join(tmpDir, 'mixed.js');
			// Less than 10% null bytes should pass
			const content = 'const x = 1;'.padEnd(100, '\0');
			fs.writeFileSync(testFile, content);

			const input: SyntaxCheckInput = {
				changed_files: [{ path: testFile, additions: 1 }],
				mode: 'changed',
			};

			const result = await syntaxCheck(input, tmpDir);

			// Should not be skipped as binary
			expect(result.files[0]?.skipped_reason).not.toBe('binary_file');
		});
	});

	// ============ Size Limit Enforcement ============

	describe('size limit enforcement', () => {
		it('skips files larger than 5MB', async () => {
			const testFile = path.join(tmpDir, 'large.js');
			// Create a file larger than 5MB
			const largeContent = 'x'.repeat(6 * 1024 * 1024);
			fs.writeFileSync(testFile, largeContent);

			const input: SyntaxCheckInput = {
				changed_files: [{ path: testFile, additions: 1 }],
				mode: 'changed',
			};

			const result = await syntaxCheck(input, tmpDir);

			expect(result.files).toHaveLength(1);
			expect(result.files[0]?.skipped_reason).toBe('file_too_large');
		});

		it('processes files exactly at 5MB limit', async () => {
			const testFile = path.join(tmpDir, 'boundary.js');
			// Create a file at exactly 5MB
			const boundaryContent = 'const x = 1;'.repeat(5 * 1024 * 1024 / 15);
			fs.writeFileSync(testFile, boundaryContent);

			const input: SyntaxCheckInput = {
				changed_files: [{ path: testFile, additions: 1 }],
				mode: 'changed',
			};

			const result = await syntaxCheck(input, tmpDir);

			// Should be processed (not skipped as too large)
			expect(result.files[0]?.skipped_reason).not.toBe('file_too_large');
		});
	});

	// ============ Feature Flag Disabled Path ============

	describe('feature flag disabled path', () => {
		it('returns pass when syntax_check is disabled', async () => {
			const testFile = path.join(tmpDir, 'test.js');
			fs.writeFileSync(testFile, 'const x = 1;');

			const input: SyntaxCheckInput = {
				changed_files: [{ path: testFile, additions: 1 }],
				mode: 'changed',
			};

			const config: PluginConfig = {
				gates: {
					syntax_check: {
						enabled: false,
					},
				},
			} as PluginConfig;

			const result = await syntaxCheck(input, tmpDir, config);

			expect(result.verdict).toBe('pass');
			expect(result.summary).toBe('syntax_check disabled by configuration');
			expect(result.files).toHaveLength(0);
		});
	});

	// ============ Unknown Extension Handling ============

	describe('unknown extension handling', () => {
		it('skips unsupported file extensions', async () => {
			const testFile = path.join(tmpDir, 'test.xyz');
			fs.writeFileSync(testFile, 'some content');

			const input: SyntaxCheckInput = {
				changed_files: [{ path: testFile, additions: 1 }],
				mode: 'changed',
			};

			const result = await syntaxCheck(input, tmpDir);

			expect(result.files).toHaveLength(1);
			expect(result.files[0]?.skipped_reason).toBe('unsupported_language');
		});

		it('filters by language when specified', async () => {
			const jsFile = path.join(tmpDir, 'test.js');
			const pyFile = path.join(tmpDir, 'test.py');
			fs.writeFileSync(jsFile, 'const x = 1;');
			fs.writeFileSync(pyFile, 'print(1)');

			const input: SyntaxCheckInput = {
				changed_files: [
					{ path: jsFile, additions: 1 },
					{ path: pyFile, additions: 1 },
				],
				mode: 'changed',
				languages: ['javascript'],
			};

			const result = await syntaxCheck(input, tmpDir);

			// Only JavaScript file should be checked
			expect(result.files).toHaveLength(1);
			expect(result.files[0]?.language).toBe('javascript');
		});
	});

	// ============ Edge Cases ============

	describe('edge cases', () => {
		it('handles non-existent files gracefully', async () => {
			const input: SyntaxCheckInput = {
				changed_files: [{ path: 'nonexistent.js', additions: 1 }],
				mode: 'changed',
			};

			const result = await syntaxCheck(input, tmpDir);

			expect(result.files).toHaveLength(1);
			expect(result.files[0]?.skipped_reason).toBe('file_read_error');
		});

		it('produces correct summary for mixed results', async () => {
			const validFile = path.join(tmpDir, 'valid.js');
			const invalidFile = path.join(tmpDir, 'invalid.js');
			fs.writeFileSync(validFile, 'const x = 1;');
			fs.writeFileSync(invalidFile, 'const x = function() { return 1;');

			const input: SyntaxCheckInput = {
				changed_files: [
					{ path: validFile, additions: 1 },
					{ path: invalidFile, additions: 1 },
				],
				mode: 'changed',
			};

			const result = await syntaxCheck(input, tmpDir);

			expect(result.summary).toContain('Syntax errors found');
		});
	});
});
