/**
 * System Enhancer Hook
 *
 * Enhances the system prompt with current phase information from the plan
 * and cross-agent context from the activity log.
 * Reads plan.md and injects phase context into the system prompt.
 */

import * as fs from 'node:fs';
import * as path from 'node:path';
import type { PluginConfig } from '../config';
import { DEFAULT_SCORING_CONFIG } from '../config/constants';
import type { RetrospectiveEvidence } from '../config/evidence-schema';
import { stripKnownSwarmPrefix } from '../config/schema';
import { loadPlan } from '../plan/manager';
import { analyzeDecisionDrift, formatDriftForContext } from '../services';
import { swarmState } from '../state';
import { warn } from '../utils';
import {
	type ContentType,
	type ContextCandidate,
	rankCandidates,
	type ScoringConfig,
} from './context-scoring';
import {
	extractCurrentPhase,
	extractCurrentPhaseFromPlan,
	extractCurrentTask,
	extractCurrentTaskFromPlan,
	extractDecisions,
} from './extractors';
import { estimateTokens, readSwarmFileAsync, safeHook } from './utils';

/**
 * Estimate content type based on text characteristics.
 */
function estimateContentType(text: string): ContentType {
	// Simple heuristics
	if (
		text.includes('```') ||
		text.includes('function ') ||
		text.includes('const ')
	) {
		return 'code';
	}
	if (text.startsWith('{') || text.startsWith('[')) {
		return 'json';
	}
	if (text.includes('#') || text.includes('*') || text.includes('- ')) {
		return 'markdown';
	}
	return 'prose';
}

/**
 * Creates the experimental.chat.system.transform hook for system enhancement.
 */
export function createSystemEnhancerHook(
	config: PluginConfig,
	directory: string,
): Record<string, unknown> {
	const enabled = config.hooks?.system_enhancer !== false;

	if (!enabled) {
		return {};
	}

	return {
		'experimental.chat.system.transform': safeHook(
			async (
				_input: { sessionID?: string; model?: unknown },
				output: { system: string[] },
			): Promise<void> => {
				try {
					const maxInjectionTokens =
						config.context_budget?.max_injection_tokens ??
						Number.POSITIVE_INFINITY;
					let injectedTokens = 0;

					function tryInject(text: string): void {
						const tokens = estimateTokens(text);
						if (injectedTokens + tokens > maxInjectionTokens) {
							return;
						}
						output.system.push(text);
						injectedTokens += tokens;
					}

					const contextContent = await readSwarmFileAsync(
						directory,
						'context.md',
					);

					// Check if scoring is enabled
					const scoringEnabled =
						config.context_budget?.scoring?.enabled === true;

					if (!scoringEnabled) {
						// Path A: EXACT LEGACY CODE - do not change
						// Priority 1: Current phase
						const plan = await loadPlan(directory);
						if (plan && plan.migration_status !== 'migration_failed') {
							const currentPhase = extractCurrentPhaseFromPlan(plan);
							if (currentPhase) {
								tryInject(`[SWARM CONTEXT] Current phase: ${currentPhase}`);
							}
							// Priority 2: Current task
							const currentTask = extractCurrentTaskFromPlan(plan);
							if (currentTask) {
								tryInject(`[SWARM CONTEXT] Current task: ${currentTask}`);
							}
						} else {
							const planContent = await readSwarmFileAsync(
								directory,
								'plan.md',
							);
							if (planContent) {
								const currentPhase = extractCurrentPhase(planContent);
								if (currentPhase) {
									tryInject(`[SWARM CONTEXT] Current phase: ${currentPhase}`);
								}
								const currentTask = extractCurrentTask(planContent);
								if (currentTask) {
									tryInject(`[SWARM CONTEXT] Current task: ${currentTask}`);
								}
							}
						}

						// Priority 3: Decisions
						if (contextContent) {
							const decisions = extractDecisions(contextContent, 200);
							if (decisions) {
								tryInject(`[SWARM CONTEXT] Key decisions: ${decisions}`);
							}

							// Priority 4 (lowest): Agent context
							if (config.hooks?.agent_activity !== false && _input.sessionID) {
								const activeAgent = swarmState.activeAgent.get(
									_input.sessionID,
								);
								if (activeAgent) {
									const agentContext = extractAgentContext(
										contextContent,
										activeAgent,
										config.hooks?.agent_awareness_max_chars ?? 300,
									);
									if (agentContext) {
										tryInject(`[SWARM AGENT CONTEXT] ${agentContext}`);
									}
								}
							}
						}

						// Priority 5 (lowest): Summarization awareness
						tryInject(
							'[SWARM HINT] Large tool outputs may be auto-summarized. Use /swarm retrieve <id> to get the full content if needed.',
						);

						// v6.0: Security review override
						if (config.review_passes?.always_security_review) {
							tryInject(
								'[SWARM CONFIG] Security review pass is MANDATORY for ALL tasks. Skip file-pattern check — always run security-only reviewer pass after general review APPROVED.',
							);
						}

						// v6.0: Integration analysis override
						if (config.integration_analysis?.enabled === false) {
							tryInject(
								'[SWARM CONFIG] Integration analysis is DISABLED. Skip diff tool and integration impact analysis after coder tasks.',
							);
						}

						// v6.1: UI/UX Designer agent opt-in
						if (config.ui_review?.enabled) {
							tryInject(
								'[SWARM CONFIG] UI/UX Designer agent is ENABLED. For tasks matching UI trigger keywords or file paths, delegate to designer BEFORE coder (Rule 9).',
							);
						}

						// v6.1: Docs agent opt-out
						if (config.docs?.enabled === false) {
							tryInject(
								'[SWARM CONFIG] Docs agent is DISABLED. Skip docs delegation in Phase 6.',
							);
						}

						// v6.2: Lint gate opt-out
						if (config.lint?.enabled === false) {
							tryInject(
								'[SWARM CONFIG] Lint gate is DISABLED. Skip lint check/fix in QA sequence.',
							);
						}

						// v6.2: Secretscan gate opt-out
						if (config.secretscan?.enabled === false) {
							tryInject(
								'[SWARM CONFIG] Secretscan gate is DISABLED. Skip secretscan in QA sequence.',
							);
						}

						// v6.2: Retrospective injection — architect-only, most recent retro
						const sessionId_retro = _input.sessionID;
						const activeAgent_retro = swarmState.activeAgent.get(
							sessionId_retro ?? '',
						);
						const isArchitect =
							!activeAgent_retro ||
							stripKnownSwarmPrefix(activeAgent_retro) === 'architect';

						if (isArchitect) {
							try {
								const evidenceDir = path.join(directory, '.swarm', 'evidence');
								if (fs.existsSync(evidenceDir)) {
									const files = fs
										.readdirSync(evidenceDir)
										.filter((f) => f.endsWith('.json'))
										.sort()
										.reverse();

									for (const file of files.slice(0, 5)) {
										let content: unknown;
										try {
											content = JSON.parse(
												fs.readFileSync(path.join(evidenceDir, file), 'utf-8'),
											);
										} catch {
											// Skip malformed evidence files
											continue;
										}
										if (
											content !== null &&
											typeof content === 'object' &&
											(content as Record<string, unknown>).type ===
												'retrospective'
										) {
											const retro = content as RetrospectiveEvidence;
											const hints: string[] = [];

											if (retro.reviewer_rejections > 2) {
												hints.push(
													`Phase ${retro.phase_number} had ${retro.reviewer_rejections} reviewer rejections.`,
												);
											}
											if (retro.top_rejection_reasons.length > 0) {
												hints.push(
													`Common rejection reasons: ${retro.top_rejection_reasons.join(', ')}.`,
												);
											}
											if (retro.lessons_learned.length > 0) {
												hints.push(
													`Lessons: ${retro.lessons_learned.join('; ')}.`,
												);
											}

											if (hints.length > 0) {
												const retroHint = `[SWARM RETROSPECTIVE] From Phase ${retro.phase_number}: ${hints.join(' ')}`;
												if (retroHint.length <= 800) {
													tryInject(retroHint);
												} else {
													tryInject(retroHint.substring(0, 800) + '...');
												}
											}
											break;
										}
									}
								}
							} catch {
								// Silently skip if evidence dir missing or unreadable
							}

							// v6.2: Soft compaction advisory
							const compactionConfig = config.compaction_advisory;
							if (compactionConfig?.enabled !== false && sessionId_retro) {
								const session = swarmState.agentSessions.get(sessionId_retro);
								if (session) {
									const totalToolCalls = Array.from(
										swarmState.toolAggregates.values(),
									).reduce((sum, agg) => sum + agg.count, 0);

									const thresholds = compactionConfig?.thresholds ?? [
										50, 75, 100, 125, 150,
									];
									const lastHint = session.lastCompactionHint || 0;

									for (const threshold of thresholds) {
										if (totalToolCalls >= threshold && lastHint < threshold) {
											const messageTemplate =
												compactionConfig?.message ??
												'[SWARM HINT] Session has ${totalToolCalls} tool calls. Consider compacting at next phase boundary to maintain context quality.';
											const message = messageTemplate.replace(
												'${totalToolCalls}',
												String(totalToolCalls),
											);
											tryInject(message);
											session.lastCompactionHint = threshold;
											break;
										}
									}
								}
							}
						}

						// v6.7: Decision drift detection — architect-only
						const automationCapabilities = config.automation?.capabilities;
						if (
							automationCapabilities?.decision_drift_detection === true &&
							_input.sessionID
						) {
							const activeAgentForDrift = swarmState.activeAgent.get(
								_input.sessionID,
							);
							const isArchitectForDrift =
								!activeAgentForDrift ||
								stripKnownSwarmPrefix(activeAgentForDrift) === 'architect';

							if (isArchitectForDrift) {
								try {
									const driftResult = await analyzeDecisionDrift(directory);
									if (driftResult.hasDrift) {
										const driftText = formatDriftForContext(driftResult);
										if (driftText) {
											tryInject(driftText);
										}
									}
								} catch {
									// Silently skip if drift analysis fails
								}
							}
						}

						return;
					}

					// Path B: Scoring is enabled - build candidates and rank
					const userScoringConfig = config.context_budget?.scoring;
					const candidates: ContextCandidate[] = [];
					let idCounter = 0;

					// Build effective config with guaranteed weights (use defaults if user config missing/invalid)
					const effectiveConfig: ScoringConfig = (
						userScoringConfig?.weights
							? {
									...DEFAULT_SCORING_CONFIG,
									...userScoringConfig,
									weights: userScoringConfig.weights,
								}
							: DEFAULT_SCORING_CONFIG
					) as ScoringConfig;

					// Build candidates from same sources as legacy
					// Current phase
					const plan = await loadPlan(directory);
					let currentPhase: string | null = null;
					let currentTask: string | null = null;

					if (plan && plan.migration_status !== 'migration_failed') {
						currentPhase = extractCurrentPhaseFromPlan(plan);
						currentTask = extractCurrentTaskFromPlan(plan);
					} else {
						const planContent = await readSwarmFileAsync(directory, 'plan.md');
						if (planContent) {
							currentPhase = extractCurrentPhase(planContent);
							currentTask = extractCurrentTask(planContent);
						}
					}

					if (currentPhase) {
						const text = `[SWARM CONTEXT] Current phase: ${currentPhase}`;
						candidates.push({
							id: `candidate-${idCounter++}`,
							kind: 'phase',
							text,
							tokens: estimateTokens(text),
							priority: 1, // legacy priority 1
							metadata: { contentType: estimateContentType(text) },
						});
					}

					// Current task
					if (currentTask) {
						const text = `[SWARM CONTEXT] Current task: ${currentTask}`;
						candidates.push({
							id: `candidate-${idCounter++}`,
							kind: 'task',
							text,
							tokens: estimateTokens(text),
							priority: 2,
							metadata: {
								contentType: estimateContentType(text),
								isCurrentTask: true,
							},
						});
					}

					// Decisions
					if (contextContent) {
						const decisions = extractDecisions(contextContent, 200);
						if (decisions) {
							const text = `[SWARM CONTEXT] Key decisions: ${decisions}`;
							candidates.push({
								id: `candidate-${idCounter++}`,
								kind: 'decision',
								text,
								tokens: estimateTokens(text),
								priority: 3,
								metadata: { contentType: estimateContentType(text) },
							});
						}

						// Agent context
						if (config.hooks?.agent_activity !== false && _input.sessionID) {
							const activeAgent = swarmState.activeAgent.get(_input.sessionID);
							if (activeAgent) {
								const agentContext = extractAgentContext(
									contextContent,
									activeAgent,
									config.hooks?.agent_awareness_max_chars ?? 300,
								);
								if (agentContext) {
									const text = `[SWARM AGENT CONTEXT] ${agentContext}`;
									candidates.push({
										id: `candidate-${idCounter++}`,
										kind: 'agent_context',
										text,
										tokens: estimateTokens(text),
										priority: 4,
										metadata: { contentType: estimateContentType(text) },
									});
								}
							}
						}
					}

					// v6.0: Security review override
					if (config.review_passes?.always_security_review) {
						const text =
							'[SWARM CONFIG] Security review pass is MANDATORY for ALL tasks. Skip file-pattern check — always run security-only reviewer pass after general review APPROVED.';
						candidates.push({
							id: `candidate-${idCounter++}`,
							kind: 'phase' as ContextCandidate['kind'],
							text,
							tokens: estimateTokens(text),
							priority: 1,
							metadata: { contentType: 'prose' as ContentType },
						});
					}

					// v6.0: Integration analysis override
					if (config.integration_analysis?.enabled === false) {
						const text =
							'[SWARM CONFIG] Integration analysis is DISABLED. Skip diff tool and integration impact analysis after coder tasks.';
						candidates.push({
							id: `candidate-${idCounter++}`,
							kind: 'phase' as ContextCandidate['kind'],
							text,
							tokens: estimateTokens(text),
							priority: 1,
							metadata: { contentType: 'prose' as ContentType },
						});
					}

					// v6.1: UI/UX Designer agent opt-in
					if (config.ui_review?.enabled) {
						const text =
							'[SWARM CONFIG] UI/UX Designer agent is ENABLED. For tasks matching UI trigger keywords or file paths, delegate to designer BEFORE coder (Rule 9).';
						candidates.push({
							id: `candidate-${idCounter++}`,
							kind: 'phase' as ContextCandidate['kind'],
							text,
							tokens: estimateTokens(text),
							priority: 1,
							metadata: { contentType: 'prose' as ContentType },
						});
					}

					// v6.1: Docs agent opt-out
					if (config.docs?.enabled === false) {
						const text =
							'[SWARM CONFIG] Docs agent is DISABLED. Skip docs delegation in Phase 6.';
						candidates.push({
							id: `candidate-${idCounter++}`,
							kind: 'phase' as ContextCandidate['kind'],
							text,
							tokens: estimateTokens(text),
							priority: 1,
							metadata: { contentType: 'prose' as ContentType },
						});
					}

					// v6.2: Lint gate opt-out
					if (config.lint?.enabled === false) {
						const text =
							'[SWARM CONFIG] Lint gate is DISABLED. Skip lint check/fix in QA sequence.';
						candidates.push({
							id: `candidate-${idCounter++}`,
							kind: 'phase' as ContextCandidate['kind'],
							text,
							tokens: estimateTokens(text),
							priority: 1,
							metadata: { contentType: 'prose' as ContentType },
						});
					}

					// v6.2: Secretscan gate opt-out
					if (config.secretscan?.enabled === false) {
						const text =
							'[SWARM CONFIG] Secretscan gate is DISABLED. Skip secretscan in QA sequence.';
						candidates.push({
							id: `candidate-${idCounter++}`,
							kind: 'phase' as ContextCandidate['kind'],
							text,
							tokens: estimateTokens(text),
							priority: 1,
							metadata: { contentType: 'prose' as ContentType },
						});
					}

					// v6.2: Retrospective injection — architect-only, most recent retro
					const sessionId_retro_b = _input.sessionID;
					const activeAgent_retro_b = swarmState.activeAgent.get(
						sessionId_retro_b ?? '',
					);
					const isArchitect_b =
						!activeAgent_retro_b ||
						stripKnownSwarmPrefix(activeAgent_retro_b) === 'architect';

					if (isArchitect_b) {
						try {
							const evidenceDir_b = path.join(directory, '.swarm', 'evidence');
							if (fs.existsSync(evidenceDir_b)) {
								const files_b = fs
									.readdirSync(evidenceDir_b)
									.filter((f) => f.endsWith('.json'))
									.sort()
									.reverse();

								for (const file of files_b.slice(0, 5)) {
									let content_b: unknown;
									try {
										content_b = JSON.parse(
											fs.readFileSync(path.join(evidenceDir_b, file), 'utf-8'),
										);
									} catch {
										// Skip malformed evidence files
										continue;
									}
									if (
										content_b !== null &&
										typeof content_b === 'object' &&
										(content_b as Record<string, unknown>).type ===
											'retrospective'
									) {
										const retro_b = content_b as RetrospectiveEvidence;
										const hints_b: string[] = [];

										if (retro_b.reviewer_rejections > 2) {
											hints_b.push(
												`Phase ${retro_b.phase_number} had ${retro_b.reviewer_rejections} reviewer rejections.`,
											);
										}
										if (retro_b.top_rejection_reasons.length > 0) {
											hints_b.push(
												`Common rejection reasons: ${retro_b.top_rejection_reasons.join(', ')}.`,
											);
										}
										if (retro_b.lessons_learned.length > 0) {
											hints_b.push(
												`Lessons: ${retro_b.lessons_learned.join('; ')}.`,
											);
										}

										if (hints_b.length > 0) {
											const retroHint_b = `[SWARM RETROSPECTIVE] From Phase ${retro_b.phase_number}: ${hints_b.join(' ')}`;
											const retroText =
												retroHint_b.length <= 800
													? retroHint_b
													: retroHint_b.substring(0, 800) + '...';
											candidates.push({
												id: `candidate-${idCounter++}`,
												kind: 'phase' as ContextCandidate['kind'],
												text: retroText,
												tokens: estimateTokens(retroText),
												priority: 2,
												metadata: { contentType: 'prose' as ContentType },
											});
										}
										break;
									}
								}
							}
						} catch {
							// Silently skip if evidence dir missing or unreadable
						}

						// v6.2: Soft compaction advisory
						const compactionConfig_b = config.compaction_advisory;
						if (compactionConfig_b?.enabled !== false && sessionId_retro_b) {
							const session_b = swarmState.agentSessions.get(sessionId_retro_b);
							if (session_b) {
								const totalToolCalls_b = Array.from(
									swarmState.toolAggregates.values(),
								).reduce((sum, agg) => sum + agg.count, 0);

								const thresholds_b = compactionConfig_b?.thresholds ?? [
									50, 75, 100, 125, 150,
								];
								const lastHint_b = session_b.lastCompactionHint || 0;

								for (const threshold of thresholds_b) {
									if (totalToolCalls_b >= threshold && lastHint_b < threshold) {
										const messageTemplate_b =
											compactionConfig_b?.message ??
											'[SWARM HINT] Session has ${totalToolCalls} tool calls. Consider compacting at next phase boundary to maintain context quality.';
										const compactionText = messageTemplate_b.replace(
											'${totalToolCalls}',
											String(totalToolCalls_b),
										);
										candidates.push({
											id: `candidate-${idCounter++}`,
											kind: 'phase' as ContextCandidate['kind'],
											text: compactionText,
											tokens: estimateTokens(compactionText),
											priority: 1,
											metadata: { contentType: 'prose' as ContentType },
										});
										session_b.lastCompactionHint = threshold;
										break;
									}
								}
							}
						}
					}

					// v6.7: Decision drift detection — architect-only
					const automationCapabilities_b = config.automation?.capabilities;
					if (
						automationCapabilities_b?.decision_drift_detection === true &&
						sessionId_retro_b
					) {
						const activeAgentForDrift_b = swarmState.activeAgent.get(
							sessionId_retro_b ?? '',
						);
						const isArchitectForDrift_b =
							!activeAgentForDrift_b ||
							stripKnownSwarmPrefix(activeAgentForDrift_b) === 'architect';

						if (isArchitectForDrift_b) {
							try {
								const driftResult_b = await analyzeDecisionDrift(directory);
								if (driftResult_b.hasDrift) {
									const driftText_b = formatDriftForContext(driftResult_b);
									if (driftText_b) {
										candidates.push({
											id: `candidate-${idCounter++}`,
											kind: 'phase' as ContextCandidate['kind'],
											text: driftText_b,
											tokens: estimateTokens(driftText_b),
											priority: 2, // High priority for drift signals
											metadata: { contentType: 'prose' as ContentType },
										});
									}
								}
							} catch {
								// Silently skip if drift analysis fails
							}
						}
					}

					// Rank candidates
					const ranked = rankCandidates(candidates, effectiveConfig);

					// Inject in ranked order under budget
					for (const candidate of ranked) {
						if (injectedTokens + candidate.tokens > maxInjectionTokens) {
							continue; // Skip if over budget
						}
						output.system.push(candidate.text);
						injectedTokens += candidate.tokens;
					}
				} catch (error) {
					warn('System enhancer failed:', error);
				}
			},
		),
	};
}

/**
 * Extracts relevant cross-agent context based on the active agent.
 * Returns a truncated string of context relevant to the current agent.
 */
function extractAgentContext(
	contextContent: string,
	activeAgent: string,
	maxChars: number,
): string | null {
	// Find the ## Agent Activity section
	const activityMatch = contextContent.match(
		/## Agent Activity\n([\s\S]*?)(?=\n## |$)/,
	);
	if (!activityMatch) return null;

	const activitySection = activityMatch[1].trim();
	if (!activitySection || activitySection === 'No tool activity recorded yet.')
		return null;

	// Build context summary based on which agent is currently active
	// The mapping tells agents what context from other agents is relevant to them
	// Strip swarm prefix to get the base agent name (e.g., "enterprise_coder" -> "coder")
	const agentName = stripKnownSwarmPrefix(activeAgent);

	let contextSummary: string;
	switch (agentName) {
		case 'coder':
			contextSummary = `Recent tool activity for review context:\n${activitySection}`;
			break;
		case 'reviewer':
			contextSummary = `Tool usage to review:\n${activitySection}`;
			break;
		case 'test_engineer':
			contextSummary = `Tool activity for test context:\n${activitySection}`;
			break;
		default:
			contextSummary = `Agent activity summary:\n${activitySection}`;
			break;
	}

	// Truncate to max chars
	if (contextSummary.length > maxChars) {
		return `${contextSummary.substring(0, maxChars - 3)}...`;
	}

	return contextSummary;
}
