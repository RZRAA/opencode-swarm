/**
 * Tests for Task 5.6 - PreflightTriggerManager vulnerability fix
 * Tests fail-safe behavior with malformed/partial automation config
 */
import { describe, expect, it } from 'bun:test';
import type { AutomationConfig } from '../config/schema';
import { getGlobalEventBus } from './event-bus';
import { PreflightTriggerManager } from './trigger';

// Helper to create event bus for testing
function createTestEventBus() {
	return getGlobalEventBus();
}

describe('PreflightTriggerManager.isEnabled() fail-safe behavior', () => {
	it('should return true for valid config with mode=auto and phase_preflight=true', () => {
		const config: AutomationConfig = {
			mode: 'auto',
			capabilities: {
				plan_sync: false,
				phase_preflight: true,
				config_doctor_on_startup: false,
				evidence_auto_summaries: false,
				decision_drift_detection: false,
			},
		};
		const manager = new PreflightTriggerManager(config, createTestEventBus());

		expect(manager.isEnabled()).toBe(true);
	});

	it('should return false when mode is manual', () => {
		const config: AutomationConfig = {
			mode: 'manual',
			capabilities: {
				plan_sync: false,
				phase_preflight: true,
				config_doctor_on_startup: false,
				evidence_auto_summaries: false,
				decision_drift_detection: false,
			},
		};
		const manager = new PreflightTriggerManager(config, createTestEventBus());

		expect(manager.isEnabled()).toBe(false);
	});

	it('should return false when phase_preflight is false', () => {
		const config: AutomationConfig = {
			mode: 'auto',
			capabilities: {
				plan_sync: false,
				phase_preflight: false,
				config_doctor_on_startup: false,
				evidence_auto_summaries: false,
				decision_drift_detection: false,
			},
		};
		const manager = new PreflightTriggerManager(config, createTestEventBus());

		expect(manager.isEnabled()).toBe(false);
	});

	it('should return false and NOT throw when capabilities is undefined', () => {
		// Vulnerability test: direct instantiation with undefined capabilities
		// Using type assertion to simulate malformed/partial config
		const config = {
			mode: 'auto',
		} as unknown as AutomationConfig;

		const manager = new PreflightTriggerManager(config, createTestEventBus());

		// Should NOT throw - should return false gracefully
		expect(manager.isEnabled()).toBe(false);
	});

	it('should return false and NOT throw when capabilities is null', () => {
		const config = {
			mode: 'auto',
			capabilities: null,
		} as unknown as AutomationConfig;

		const manager = new PreflightTriggerManager(config, createTestEventBus());

		// Should NOT throw - should return false gracefully
		expect(manager.isEnabled()).toBe(false);
	});

	it('should return false when capabilities is an empty object', () => {
		const config = {
			mode: 'auto',
			capabilities: {},
		} as unknown as AutomationConfig;

		const manager = new PreflightTriggerManager(config, createTestEventBus());

		// Should NOT throw - should return false (phase_preflight undefined !== true)
		expect(manager.isEnabled()).toBe(false);
	});

	it('should work correctly with checkAndTrigger when capabilities is undefined', async () => {
		const config = {
			mode: 'auto',
			// capabilities is undefined - should not crash
		} as unknown as AutomationConfig;

		const manager = new PreflightTriggerManager(config, createTestEventBus());

		// Should not throw
		const result = await manager.checkAndTrigger(1, 1, 5);

		// Should return false because isEnabled() returns false
		expect(result).toBe(false);
	});
});
